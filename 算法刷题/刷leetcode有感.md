


# 链表环问题

## 判断链表是否有环
leetcode上的[原题](https://leetcode.com/problems/linked-list-cycle/description/)，解法也比较简单：用快慢两个指针(快指针一次走两步，慢指针一次走一步)从头开始死循环遍历。如果碰到`NULL`说明链表没有环，否则当两个指针相等时就会说明有环。`accept`的代码如下：

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr || head->next == nullptr) return false;

        ListNode *slow = head, *fast = head;

        while(fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;

            if(slow == fast)
                break;
        }

        return slow == fast;
    }
};
```

## 一定会偶遇？
现在挖掘机来了，为什么前面的快慢指针一定会相遇？假设链表存在环，并且设定快指针一次走3步，慢指针一次走1步，它们一定还会相遇吗？

利用物理的相对运动来看一下这个问题。从慢指针的角度来说，慢指针静止不动，快指针每次走一步。环虽大，但快指针一次逼近我一步，迟早会相遇的。但如果快指针每次走两步，那么在逼近我的时候，可能会刚好跨过我，分别在我是左边和右边落脚。

从上面的定性分析来看，快指针一次走2步一定会相遇的，但一次走3步就不一定了。下面来看一下定量的计算。从慢指针刚踏进环的那一个位置开始，计算相对移动情况(不用考虑花了多少步才进入环)。假设环的长度为`c`, 慢指针刚踏进环的时候，快指针的位置为`k`(显然有`k<c`)，快慢指针的相对速度是`s`。要使得两个指针能相遇也就是要有：`(s*n+k) % c = 0`。显然当`s`等于2、`k`等于1、`c`等于4时，是任何整数`n`都无法使得等式成立，也就是永远无法相遇。

现在用数论分析，上面的余数等式可以改写成`n*s + k = m*c`，不考虑正负性的话，进一步改写成`n*s + m*c = k`。现在的问题可以改成：是否对于特定的s、c、k，是否存在整数n、m使得等式成立。数学上已经有一些结论了：**对于`n*s + m*c`其必然等于s和c的最大公约数的倍数**。也就是说如果k等于gcd(s, c)的倍数，那么两个指针会相遇，否则无法相遇。

回到原题，对于快指针每次走2步的情况。相对速度s等于1，那么无论圆的长度c是多大，最大公约数都是1于是k都是他们最大公约数的倍数，于是他们一定会相遇。


## 找到环的开始位置
先看一个问题：对于快指针每次走2步情况。当快慢指针相遇的时候，慢指针有没有走完一圈？答案是还没有。还是从相对速度上考虑：每次逼近一步，如果快指针在什么位置，相遇所需的逼近次数都不会大于等于圆的周长。显然，逼近次数也就是慢指针走的步数，所以当快慢指针相遇时，慢指针还没走完一圈。

现在看leetcode上的一个问题[求环开始位置](https://leetcode.com/problems/linked-list-cycle-ii/description/)。假设从链表头部到环开始位置的节点数为`a`，环的周长为`c`，快慢指针相遇时，慢指针的位置相对于环开始是`b`。那么相遇时，慢指针走了`a+b`个节点，快指针则为`2*(a+b)`。慢指针在环中跨越的节点数为`b`，而快指针为`2*(a+b)-a`，由两者相遇可以得到`(2(a+b)-a)%c = b`，也就是`2*b+a = n*c + b`，即`a+b = n*c`。这已经很明显了，现在慢指针已经在b位置上，再走a步就可以回到环的开始位置。而a等于从链表头到环开始位置的节点数。

