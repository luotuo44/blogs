命令`gcc -fPIC -shared -o libtest.so test.c`可以得到一个位置无关的动态库。其中`-fPIC`用于位置无关，`-shared`用于得到动态库。
## 位置无关
什么叫位置无关呢？位置无关是指无论动态库加载到进程的任意位置都能正确运行。为了理解这点，我们先来看位置**相**关是怎么样的。一般来说，函数内部要使用某个变量，在汇编层是通过偏移量找到该变量并操作的。下面是使用函数局部变量的汇编代码，可以观察到对变量a赋值是通过[ebp-4]这个偏移量实现的。
```cpp
0x4022c6                   55                             push   ebp
0x4022c7  <+0x0001>        89 e5                          mov    ebp,esp
0x4022c9  <+0x0003>        83 ec 10                       sub    esp,0x10
        146 [1]	    int a = 3;
0x4022cc  <+0x0006>        c7 45 fc 03 00 00 00           mov    DWORD PTR [ebp-0x4],0x3
        147 [1]	    int b = 5;
0x4022d3  <+0x000d>        c7 45 f8 05 00 00 00           mov    DWORD PTR [ebp-0x8],0x5
        149 [1]	    a = 4;
0x4022da  <+0x0014>        c7 45 fc 04 00 00 00           mov    DWORD PTR [ebp-0x4],0x4
        150 [1]	    b += 3;
0x4022e1  <+0x001b>        83 45 f8 03                    add    DWORD PTR [ebp-0x8],0x3
```
对于全局变量，它们是保存到`.data`或者`.bss`的(区别在于前者保存有初始化的全局变量，后者保存未初始化全局变量)。假如是静态链接，那么在链接阶段，链接器会先摆放好这些`.data`、`.bss`以及代码段`.text`。当这些段都摆放好之后，也就是彼此之间的相对位置不会再变动。此时，链接器再去逐一修改代码段中的那些使用了全局变量的汇编代码，修改成相对偏移量。

上面静态库的做法无法应用于动态库。一来，因为动态库被加载到进程的位置是未知的(也就是不到加载那刻相对位置是不能确定的)。二来，静态链接会拷贝一份静态库代码到可执行程序，然后修改这份拷贝的代码。但动态库只会有一份，会同时被多个进程所共享，并且动态库加载到多个进程时得到的虚拟地址也不同，因此即使修改了也无法满足多个进程同时使用。

## 实现位置无关
前面解释了什么叫位置无关，那么动态库是如何实现的呢？下面以变量为例子解释一下。
### 函数局部变量
这个和前面给的示范汇编一样，只需寄存器`ebp`以及栈内偏移量就可以了。
### 静态全局变量
首先，对于动态库会有一个属于它自己的`.data`段。**这个数据段是不会被多个进程所共享的**，也就是每个进程都有会仅属于自己的一份拷贝，不然同一个全局变量在A进程被修改，B进程能看到。当进程加载动态库的时候，动态库的代码段和数据段的相对位置是不变的(即使代码段是多个进程共享，数据段的当前进程所独有的)。利用这个相对位置不变，那么就可以将静态全局变量存放到该数据段中，然后在代码段中直接使用这个相对偏移量即可。

### 全局变量
这里的全局变量包括下面两种
```cpp
int g_a = 3;
extern int g_b;
```
前面提及的静态全局变量由于其他模块无法访问，因此可以放到动态库所关联的那个`.data`数据段。但这里的全局变量是会被其他模块所使用。因此这里的全局变量是存放到可执行程序的那个`.data`或者`.bss`段中。为了做到位置无关，动态库独有的那个`.data`段中需要有一个`GOT`（Global Offset Table）表。显然，动态库代码段和这个`GOT`表的相对位置是固定的。`GOT`表项也简单，就是定义了全局变量以及它所在的位置。当动态库被加载的时候，加载器负责修改`GOT`表，为每个全局变量设置正确的位置。